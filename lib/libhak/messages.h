/*  messages.h - Messages generated by libhak.
    
    Copyright 2013  Francisco Jose Monaco   <monaco.fj@gmail.com>

    This file is part of Libhak. 

    Libhak is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Libhak is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with .  If not, see <http://www.gnu.org/licenses/>. 

*/

#ifndef _HAK_MESSAGES_H
#define _HAK_MESSAGES_H

#include <config.h>
#include <errno.h>
#include <string.h>

/* 
   Macros controlling behavior of error reporting functions.
*/

/* Whether hak_sysfault will call exit or not. */
#ifndef HAK_SYSFAULT_FATAL
#define HAK_SYSFAULT_FATAL HAK_TRUE	
#endif

/* Whether hak_assert will be compiled or not. */
#ifndef HAK_ASSERT
#define HAK_ASSERT HAK_TRUE
#endif
#ifndef HAK_ASSERT_FATAL	/* Whether it will call exit or not. */
#define HAK_ASSERT_FATAL HAK_FALSE	
#endif

/* Whether hak_verify will call exit or return. */
#ifndef HAK_VERIFY_FATAL
#define HAK_VERIFY_FATAL HAK_TRUE	
#endif

/* 
   If HAD_DEVMODE==1, all error checks are nonfatal.  
*/

#if HAK_DEVMODE==1
#undef HAK_SYSFAULT_FATAL
#undef HAK_ASSERT
#undef HAK_ASSERT_FATAL
#undef HAK_VERIFY_FATAL
#define HAK_SYSFAULT_FATAL HAK_FALSE
#define HAK_ASSERT HAK_TRUE
#define HAK_ASSERT_FATAL HAL_FALSE
#define HAK_VERIFY_FATAL HAK_FALSE
#endif


/* Empty string if some logging symbol is NULL */

#define hak_symbol_string(type) (hak_engine.symbol_ ## type ? hak_engine.symbol_ ## type : "")

/* Provision for gettext (not currently implemented) 
   It should be #define _(string) gettext(string) if HAVE_GETTEXT==1 
*/

#define _(string) string

/* 
   Libhak sysfault: check and report system faults (syscall faults).
  
   If 'expression' is true, report error messagem conforming errno variable,
   and optionally exit with EXIT_FAILURE.
 */

/* System fatal error. */
#define hak_sysfault_fatal(expression) do{ if (expression) {fprintf (stderr, "%s%s: %s: %d: %s\n", hak_symbol_string(sysfault),hak_engine.program_name, __FILE__, __LINE__, strerror(errno)); exit (EXIT_FAILURE);}}while(0)

/* System non-fatal error. */
#define hak_sysfault_nonfatal(expression) do{ if (expression) {fprintf (stderr,"%s%s: %s: %d: %s\n", hak_symbol_string(sysfault), hak_engine.program_name, __FILE__, __LINE__, strerror(errno));}}while(0)

/* System error: fatal if HAK_SYSFATAL is defined; non-fatal oterwise. 
   HAK_SYSFATAL is true by default. */

#if (HAK_SYSFAULT_FATAL != HAK_FALSE) 
#define hak_sysfault(expression) hak_sysfault_fatal(expression)
#else
#define hak_sysfault(expression) hak_sysfault_nonfatal(expression)
#endif	/* HAK_SYSFATAL */



/* Values of hak_engine.errno */

typedef enum
  {
    hak_verify_ok,                       /* Success.*/
    hak_verify_fault		         /* Unspecified fault. */
  } hak_verify_code_t;

extern const char* hak_error_messages[];

#define _hak_set_error(error_code) do{hak_engine.error = error_code;}while(0)

/* Log symbols */

typedef enum 
  {
    hak_symbol_log,	
    hak_symbol_sysfault,
    hak_symbol_verify,
    hak_symbol_assert,
    hak_symbol_check
  } hak_symbol_t;

extern const char* hak_symbols[]; 




/* 
  Libhak verify: check for conditions prone to cause either runtime faults
  or incorrect results.  These may include calling a function with invalid 
  parameters (e.g. passing NULL to strdup), freeing a non-allocated memory 
  block (e.g. if using hak_malloc), and so on.

  If 'expression' is true, report a specific 'error_message' and either return
  with a given 'return_value', or exit with EXIT_FAILURE.

 */

#define hak_verify_fatal(expression, error_code) do{_hak_set_error(hak_verify_ok); if (expression) {_hak_set_error(hak_verify_fault); fprintf (stderr, "%s%s: %s: %d: %s\n", hak_symbol_string(verify), hak_engine.program_name, __FILE__, __LINE__, hak_error_messages[error_code]); exit (EXIT_FAILURE);}}while(0)

#define hak_verify_nonfatal(expression, error_code, return_value) do{_hak_set_error(hak_verify_ok); if (expression) {_hak_set_error(hak_verify_fault); fprintf (stderr, "%s%s: %s: %d: %s\n", hak_symbol_string(verify), hak_engine.program_name, __FILE__, __LINE__, hak_error_messages[error_code]); return return_value;}}while(0)

/* Libhak error: fatal if HAK_FATAL is defined; non-fatal otherwise. */

#if (HAK_VERIFY_FATAL != HAK_FALSE) 
#define hak_verify(expression, code, value) hak_verify_fatal(expression, code)
#else
#define hak_verify(expression, code, value) hak_verify_nonfatal(expression, code, value)
#endif	/* HAK_VERIFY_FATAL */



/* 
   hak_assert: conditions that should never happen. It's a bug.

   If 'expression' is true, exhibit the asserted condition (the stringfied expression)
   and a customized 'error_message', it non NULL.  
 */

#define hak_assert_fatal(expression, error_message) do{if (expression) {fprintf (stderr, "%s%s: %s: %d: %s %s\n", hak_symbol_string(assert), hak_engine.program_name, __FILE__, __LINE__, #expression, error_message ? error_message : ""); exit (EXIT_FAILURE);}}while(0)


#define hak_assert_nonfatal(expression, error_message) do{ if (expression) {fprintf (stderr, "%s%s: %s: %d: %s %s\n", hak_symbol_string(assert), hak_engine.program_name, __FILE__, __LINE__, #expression, error_message ? error_message : "");}}while(0)

/* Libhak assert: fatal if HAK_FATAL is defined; nonfatal otherwise. */
   
#if (HAK_ASSERT_FATAL != HAK_FALSE)
#define hak_assert(expression, message) hak_assert_fatal(expression, message)
#else
#define hak_assert(expression, message) hak_assert_nonfatal(expression, message)
#endif	/* HAK_FATAL */

#if (HAK_ASSERT == HAK_FALSE)
#undef hak_assert_fatal
#undef hak_assert_nonfatal
#undef hak_assert
#define hak_assert_fatal(expression, errror) while(0)
#define hak_assert_nonfatal(expression, errror) while(0)
#define hak_assert(expression, errror) while(0)
#endif



/* 
  Libhak check: user customized checks.

  If 'expression' is true, report a specific 'error_message' and either return
  with a given 'return_value', or exit with EXIT_FAILURE.

 */

#define hak_check_fatal(expression, error_message) do{ if (expression) {fprintf (stderr, "%s%s: %s: %d: %s\n", hak_symbol_string(check), hak_engine.program_name, __FILE__, __LINE__, error_message ? _(error_message) : ""); exit (EXIT_FAILURE);}}while(0)

#define hak_check_nonfatal(expression, error_message, return_value) do{ if (expression) {fprintf (stderr, "%s%s: %s: %d: %s\n", hak_symbol_string(check), hak_engine.program_name, __FILE__, __LINE__, error_message ? _(error_message): ""); return return_value;}}while(0)


/* Libhak log: general log messages (variable arguments) */
int hak_log (const char *, ...);

const char *hak_replaced;

#endif /* _HAK_MESSAGES_H */


